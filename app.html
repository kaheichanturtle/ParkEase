<!-- 
License

Copyright 2025 Ka Hei Chan and Shellcraft Studios. Unauthorized copying is prohibited.

ParkEase and all associated content, code, and intellectual property are protected under copyright law. Unauthorized use, reproduction, distribution, or modification of this project, in whole or in part, is strictly prohibited without prior written consent from the copyright holder.

Permissions
- Viewing: You are allowed to view the content and code for personal or educational purposes.
- Forking: Forking this repository is not allowed. Please contact me at 2uh114cu@duck.com 

Restrictions
- Commercial Use: You may not use this project or any derivative works for commercial purposes without explicit permission.
- Distribution: You may not distribute, publish, or sell any part of this project without prior written consent.
- Modification: You may not modify, adapt, or create derivative works without explicit permission.

Attribution
If you use or reference this project in any way, you must provide proper attribution by linking back to the original repository:  
[ParkEase Repository](https://github.com/kaheichanturtle/Parkease)

Legal Notice
Any unauthorized use of this project may result in legal action. For inquiries regarding permissions, licensing, or collaborations, please contact us at 2uh114cu@duck.com.

---
Copyright © 2025 Ka Hei Chan. All rights reserved.

-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>ParkEase</title>
    <meta name="theme-color" content="#4a90e2" />
    <link rel="manifest" href="/manifest.json" />
    <link
      rel="apple-touch-icon"
      href="https://cdn.glitch.global/cbdf53ed-1d1e-441b-8c47-ff223e3a04c8/android-launchericon-192-192.png?v=1741136144106"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="192x192"
      href="https://cdn.glitch.global/cbdf53ed-1d1e-441b-8c47-ff223e3a04c8/android-launchericon-192-192.png?v=1741136144106"
    />

    <!-- Leaflet CSS -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />

    <style>
      :root {
        --primary: #4a90e2;
        --primary-light: #7eb4ff;
        --primary-dark: #2d6fc8;
        --text: #333333;
        --text-light: #666666;
        --background: #f8f9fa;
        --card: #ffffff;
        --success: #34c759;
        --warning: #ffcc00;
        --danger: #ff3b30;
        --disabled-blue: #007bff;
        --gray: #e0e0e0;
        --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        --radius: 12px;
        --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        --bottom-nav-height: 60px;
      }
      body.dark-mode {
        --primary: #58a6ff;
        --primary-light: #79b8ff;
        --primary-dark: #388bfd;
        --text: #c9d1d9;
        --text-light: #8b949e;
        --background: #0d1117;
        --card: #161b22;
        --success: #238636;
        --warning: #e3b341;
        --danger: #da3633;
        --disabled-blue: #1f6feb;
        --gray: #21262d;
        --shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
      }
      html,
      body {
        height: 100%;
        overflow: hidden;
      }
      body {
        background-color: var(--background);
        color: var(--text);
        overscroll-behavior-y: contain;
        transition: background-color 0.3s, color 0.3s;
      }

      /* --- Install Gate --- */
      #install-gate {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: var(--background);
        color: var(--text);
        display: flex; /* Changed to flex by default, JS hides if installed */
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 30px;
        text-align: center;
        z-index: 2000; /* Highest */
        transition: opacity 0.5s ease-out; /* Optional fade out */
      }
      #install-gate h2 {
        color: var(--primary);
        margin-bottom: 15px;
        font-size: 24px;
      }
      #install-gate p {
        margin-bottom: 25px;
        line-height: 1.6;
        font-size: 16px;
        max-width: 400px;
        color: var(--text-light);
      }
      .install-instructions {
        display: none; /* Hide sections initially */
        padding: 20px;
        background-color: var(--card);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        margin-top: 20px;
      }
      .install-instructions h3 {
        margin-bottom: 15px;
        font-size: 18px;
        color: var(--primary);
      }
      .install-instructions p {
        font-size: 14px;
        margin-bottom: 15px;
        color: var(--text);
      }
      .install-instructions svg {
        /* Style for iOS share icon */
        display: inline-block;
        vertical-align: middle;
        margin: 0 4px;
        width: 22px; /* Slightly larger */
        height: 22px;
        stroke: var(--primary); /* Use primary color for icon */
      }
      #install-btn-android {
        /* Style the Android button */
        /* Uses .button .primary-button styles */
      }

      .app-container {
        display: flex;
        flex-direction: column;
        height: 100%;
        max-width: 500px;
        margin: 0 auto;
        background-color: var(--background);
        position: relative;
        /* Initially hidden if install gate is shown */
        /* visibility: hidden;  Might cause layout issues, prefer gate overlay */
      }

      /* --- Main Content Area --- */
      .main-content {
        flex-grow: 1;
        overflow-y: auto;
        padding: 16px;
        padding-bottom: calc(var(--bottom-nav-height) + 16px);
      }

      /* --- PWA Install Banner (REMOVED - Replaced by Install Gate) --- */

      /* Other styles remain largely the same... */
      #camera-section,
      #map-section {
        margin-bottom: 16px;
      }
      #map-section {
        display: none;
        height: 250px;
        border-radius: var(--radius);
        overflow: hidden;
        box-shadow: var(--shadow);
      }
      #map {
        height: 100%;
        width: 100%;
      }
      #video,
      #capturedImage {
        width: 100%;
        max-height: 500px;
        object-fit: cover;
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        background: var(--gray);
        transition: var(--transition);
        display: block;
      }
      #capturedImage {
        display: none;
      }
      .button-container {
        padding: 0 0 16px 0;
      }
      .button {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        padding: 14px;
        font-size: 16px;
        font-weight: 600;
        border: none;
        border-radius: var(--radius);
        margin-top: 12px;
        cursor: pointer;
        transition: var(--transition);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        color: white;
        outline: none;
      }
      .button svg {
        margin-right: 8px;
        flex-shrink: 0;
      }
      .primary-button {
        background: var(--primary);
      }
      .primary-button:hover {
        background: var(--primary-dark);
        transform: translateY(-2px);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      }
      .danger-button {
        background: var(--danger);
      }
      .danger-button:hover {
        background: color-mix(in srgb, var(--danger) 90%, black);
        transform: translateY(-2px);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      }
      #captureBtn {
        display: flex;
      }
      #retakeBtn {
        display: none;
      }
      .sign-container {
        display: flex;
        gap: 16px;
        margin-bottom: 16px;
        opacity: 0;
        transform: translateY(20px);
        transition: var(--transition);
        height: 0;
        overflow: hidden;
      }
      .sign-container.visible {
        opacity: 1;
        transform: translateY(0);
        height: auto;
      }
      .sign-card {
        flex: 1;
        border-radius: var(--radius);
        overflow: hidden;
        box-shadow: var(--shadow);
        background: var(--card);
        transition: var(--transition);
      }
      .sign-header {
        padding: 10px 12px;
        color: white;
        font-weight: 600;
        text-align: center;
        font-size: 11px;
        line-height: 1.3;
      }
      .allowed {
        background: var(--success);
      }
      .ticket {
        background: var(--warning);
        color: #333 !important;
      }
      .no-parking {
        background: var(--danger);
      }
      .disabled-allowed {
        background: var(--disabled-blue);
      }
      .sign-body {
        padding: 12px 16px;
      }
      .sign-row {
        display: flex;
        margin-bottom: 6px;
        font-size: 12px;
      }
      .sign-label {
        flex: 0 0 60px;
        font-weight: 600;
        color: var(--text-light);
      }
      .sign-value {
        flex: 1;
        color: var(--text);
      }
      .timer-card-container {
        position: relative;
        margin-bottom: 25px;
      }
      .timer-card {
        background: var(--card);
        border-radius: var(--radius);
        padding: 20px;
        box-shadow: var(--shadow);
        text-align: center;
        transition: var(--transition);
        display: none;
      }
      .timer-label {
        font-size: 14px;
        color: var(--text-light);
        margin-bottom: 8px;
      }
      .time-display {
        font-size: 32px;
        font-weight: 700;
        color: var(--primary);
        margin-bottom: 8px;
      }
      .expires-at {
        font-size: 14px;
        color: var(--text-light);
      }
      #stopTimerBtn {
        display: none;
        position: absolute;
        bottom: -30px;
        left: 50%;
        transform: translateX(-50%);
        width: auto;
        min-width: 120px;
        background-color: var(--danger);
        color: white;
        border: none;
        border-radius: 25px;
        padding: 10px 25px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        box-shadow: var(--shadow);
        z-index: 10;
        transition: var(--transition);
      }
      #stopTimerBtn:hover {
        background-color: color-mix(in srgb, var(--danger) 85%, black);
      }
      #aiDetailsSection {
        margin-bottom: 16px;
        display: none;
      }
      .collapsible {
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 100%;
        padding: 12px 16px;
        background: var(--gray);
        border: none;
        text-align: left;
        font-size: 14px;
        font-weight: 500;
        color: var(--text);
        border-radius: var(--radius);
        cursor: pointer;
        transition: var(--transition);
        margin-top: 8px;
      }
      .collapsible:hover {
        background: color-mix(in srgb, var(--gray) 90%, black);
      }
      .chevron {
        transition: var(--transition);
      }
      .collapsible.active .chevron {
        transform: rotate(180deg);
      }
      .content {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease-out;
        background: var(--card);
        border-radius: 0 0 var(--radius) var(--radius);
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
      }
      .ai-response {
        padding: 16px;
        font-size: 13px;
        white-space: pre-wrap;
        word-break: break-word;
        overflow-x: auto;
        background: var(--background);
        border-radius: var(--radius);
        margin: 12px;
        border: 1px solid var(--gray);
      }
      .modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease-in-out;
      }
      .modal.visible {
        opacity: 1;
        pointer-events: auto;
      }
      .modal-content {
        width: 90%;
        max-width: 400px;
        background: var(--card);
        border-radius: var(--radius);
        padding: 24px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        transform: scale(0.95);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        max-height: 85vh;
        overflow-y: auto;
        position: relative;
      }
      .modal.visible .modal-content {
        transform: scale(1);
      }
      .modal-title {
        font-size: 18px;
        font-weight: 600;
        margin-bottom: 20px;
        text-align: center;
        color: var(--text);
      }
      .modal-close-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        background: none;
        border: none;
        font-size: 24px;
        color: var(--text-light);
        cursor: pointer;
        line-height: 1;
        padding: 5px;
      }
      .modal-buttons {
        display: flex;
        gap: 12px;
        margin-top: 20px;
      }
      .modal-button {
        flex: 1;
      }
      #ticket-time-options {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
        gap: 10px;
      }
      .time-option-btn {
        background-color: var(--gray);
        color: var(--text);
        padding: 10px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 500;
        transition: background-color 0.2s;
        text-align: center;
      }
      .time-option-btn:hover {
        background-color: var(--primary);
        color: white;
      }
      #settings-modal .modal-content {
      }
      .settings-section {
        margin-bottom: 20px;
        border-bottom: 1px solid var(--gray);
        padding-bottom: 16px;
      }
      .settings-section:last-child {
        border-bottom: none;
        padding-bottom: 0;
      }
      .settings-section h3 {
        font-size: 16px;
        font-weight: 600;
        margin-bottom: 12px;
        color: var(--primary);
      }
      .setting-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }
      .setting-item label {
        font-size: 14px;
        color: var(--text);
        margin-right: 10px;
      }
      .toggle-switch {
        position: relative;
        display: inline-block;
        width: 40px;
        height: 20px;
        flex-shrink: 0;
      }
      .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: var(--gray);
        transition: 0.4s;
        border-radius: 20px;
      }
      .slider:before {
        position: absolute;
        content: "";
        height: 14px;
        width: 14px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
      }
      input:checked + .slider {
        background-color: var(--primary);
      }
      input:checked + .slider:before {
        transform: translateX(20px);
      }
      #historyModal .modal-content {
      }
      #history-list {
        list-style: none;
        padding: 0;
      }
      #history-list li {
        background: var(--background);
        padding: 10px;
        margin-bottom: 8px;
        border-radius: 8px;
        font-size: 13px;
        cursor: pointer;
        border: 1px solid var(--gray);
      }
      #history-list li:hover {
        background: var(--gray);
      }
      .history-entry span {
        display: block;
        margin-bottom: 4px;
      }
      .history-entry .date {
        font-weight: 600;
      }
      .history-entry .details {
        color: var(--text-light);
        font-size: 12px;
      }
      #history-detail-modal .modal-content {
      }
      #history-detail-map {
        height: 150px;
        width: 100%;
        margin-bottom: 10px;
        border-radius: var(--radius);
      }
      #history-detail-content p {
        margin-bottom: 8px;
        font-size: 14px;
      }
      .status-message {
        position: fixed;
        bottom: calc(var(--bottom-nav-height) + 10px);
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        border-radius: 24px;
        box-shadow: var(--shadow);
        z-index: 900;
        transition: transform 0.3s ease-out, opacity 0.3s ease-out;
        pointer-events: none;
        opacity: 0;
        text-align: center;
        max-width: 90%;
        transform: translateX(-50%) translateY(100px);
      }
      .status-message.visible {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
      }
      .fade-in {
        animation: fadeIn 0.5s forwards;
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }
      .pulse {
        animation: pulse 2s infinite;
      }
      @keyframes pulse {
        0% {
          box-shadow: 0 0 0 0
            color-mix(in srgb, var(--primary) 40%, transparent);
        }
        70% {
          box-shadow: 0 0 0 10px
            color-mix(in srgb, var(--primary) 0%, transparent);
        }
        100% {
          box-shadow: 0 0 0 0 color-mix(in srgb, var(--primary) 0%, transparent);
        }
      }
      .current-location-marker {
        background-color: #3498db;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        border: 2px solid white;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
      }
      .saved-location-marker {
        background-color: #e74c3c;
        width: 20px;
        height: 20px;
        border-radius: 50% 50% 50% 0;
        border: 2px solid white;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        transform: rotate(-45deg);
      }
      .leaflet-div-icon {
        background: none;
        border: none;
      }
      .bottom-nav {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        max-width: 500px;
        margin: 0 auto;
        height: var(--bottom-nav-height);
        background-color: var(--card);
        display: flex;
        justify-content: space-around;
        align-items: center;
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        border-top: 1px solid var(--gray);
        z-index: 600;
      }
      .nav-btn {
        background: none;
        border: none;
        color: var(--text-light);
        display: flex;
        flex-direction: column;
        align-items: center;
        font-size: 10px;
        padding: 6px 10px;
        cursor: pointer;
        transition: color 0.2s;
        flex-grow: 1;
        height: 100%;
      }
      .nav-btn svg {
        width: 24px;
        height: 24px;
        margin-bottom: 4px;
      }
      .nav-btn.active,
      .nav-btn:hover {
        color: var(--primary);
      }
      .map-button {
        background-color: var(--primary-light); /* Use primary light */
        color: var(--card); /* White or near-white text */
        padding: 8px 16px; /* Smaller padding */
        font-size: 14px; /* Slightly smaller font */
        font-weight: 500;
        width: auto; /* Don't force full width */
        display: inline-flex; /* Use flex to align icon and text */
        align-items: center;
        margin-top: 0; /* Reset margin if needed from .button */
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1); /* Lighter shadow */
        border: none; /* Ensure no border */
      }

      .map-button:hover {
        background-color: var(--primary); /* Darken slightly on hover */
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        transform: translateY(-1px);
      }

      /* Ensure containers are centered */
      #openMapBtnContainerMain,
      #openMapBtnContainerHistory {
        text-align: center;
      }
    </style>
  </head>
  <body>
    <!-- Install Gate - Shown Only if Not Installed -->
    <div id="install-gate">
      <h2>Welcome to ParkEase</h2>
      <p>
        For the best experience, including ensuring background functionality for
        accurate timers and better battery optimisation, please install the
        ParkEase app to your Home Screen.
        
      </p>

      <!-- iOS Install Instructions -->
      <div id="ios-install-prompt" class="install-instructions">
        <h3>Install on iOS</h3>
        <p>
          Tap the Share button
          <svg
            width="18"
            height="18"
            viewBox="0 0 24 24"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M12 3V15M8 6L12 2L16 6M5 9V19C5 19.5304 5.21071 20.0391 5.58579 20.4142C5.96086 20.7893 6.46957 21 7 21H17C17.5304 21 18.0391 20.7893 18.4142 20.4142C18.7893 20.0391 19 19.5304 19 19V9"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
          in your browser menu, then scroll down and select 'Add to Home
          Screen'.
        </p>
      </div>

      <!-- Android Install Instructions -->
      <div id="android-install-prompt" class="install-instructions">
        <h3>Install on Android</h3>
        <p>Tap the button below to add ParkEase to your device.</p>
        <button id="install-btn-android" class="button primary-button" disabled>
          Checking availability...
        </button>
      </div>

      <!-- Fallback for other OS -->
      <div id="other-os-prompt" class="install-instructions">
        <h3>Installation</h3>
        <p>
          Please continue on mobile by scanning this QR code. (On mobile? Use
          Safari on IOS or Chrome on Android and try again.)
        </p>
        <img
          src="https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=www.parkease.glitch.me/app.html"
          alt="ParkEase QR Code"
        />
      </div>
      <p>
        <br>
        <br>
        By installing, you agree to ParkEase's Terms and Conditions.
      </p>
    </div>

    <!-- Main App Container (Content loaded only if installed) -->
    <div class="app-container">
      <!-- Main Content Scrollable Area -->
      <div class="main-content">
        <!-- App Content Goes Here (Instructions, Camera, Map, Timer etc.) -->
        <!-- Instruction -->
        <div
          class="instruction fade-in"
          style="
            display: flex;
            align-items: center;
            padding: 12px 20px;
            margin-bottom: 16px;
            background: var(--primary-light);
            color: white;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            font-weight: 500;
          "
        >
          <svg
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
            style="margin-right: 12px; flex-shrink: 0"
          >
            <path
              d="M12 16V12M12 8H12.01M22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12Z"
              stroke="white"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
          <span>Remember to turn up your device's volume for the alarm!</span>
        </div>
        <!-- Camera Section -->
        <div id="camera-section">
          <video id="video" autoplay playsinline muted></video>
          <img id="capturedImage" alt="Captured parking sign" />
          <canvas id="canvas" style="display: none"></canvas>
        </div>
        <!-- Map Section -->
        <div id="map-section"><div id="map"></div></div>
        <div
          id="openMapBtnContainerMain"
          style="
            text-align: center;
            display: none;
            margin-top: 8px;
            margin-bottom: 8px;
          "
        >
          <button id="openMapBtnMain" class="button map-button">
            <svg
              width="16"
              height="16"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
              style="margin-right: 6px"
            >
              <path
                d="M21 10C21 17 12 23 12 23C12 23 3 17 3 10C3 7.61305 3.94821 5.32387 5.63604 3.63604C7.32387 1.94821 9.61305 1 12 1C14.3869 1 16.6761 1.94821 18.364 3.63604C20.0518 5.32387 21 7.61305 21 10Z"
                stroke="white"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
              <path
                d="M12 13C13.6569 13 15 11.6569 15 10C15 8.34315 13.6569 7 12 7C10.3431 7 9 8.34315 9 10C9 11.6569 10.3431 13 12 13Z"
                stroke="white"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
            Open in Google Maps
          </button>
        </div>
        <!-- Sign Graphs -->
        <div id="signGraphs" class="sign-container">
          <div class="sign-card" id="leftSignCard">
            <div class="sign-header" id="leftSignHeader">LEFT SIDE</div>
            <div class="sign-body">
              <div class="sign-row">
                <div class="sign-label">Time:</div>
                <div class="sign-value" id="leftTime">-</div>
              </div>
              <div class="sign-row">
                <div class="sign-label">Sign:</div>
                <div class="sign-value" id="leftSign">-</div>
              </div>
              <div class="sign-row">
                <div class="sign-label">Ticket:</div>
                <div class="sign-value" id="leftTicket">-</div>
              </div>
              <div class="sign-row">
                <div class="sign-label">Disabled:</div>
                <div class="sign-value" id="leftDisabled">-</div>
              </div>
            </div>
          </div>
          <div class="sign-card" id="rightSignCard">
            <div class="sign-header" id="rightSignHeader">RIGHT SIDE</div>
            <div class="sign-body">
              <div class="sign-row">
                <div class="sign-label">Time:</div>
                <div class="sign-value" id="rightTime">-</div>
              </div>
              <div class="sign-row">
                <div class="sign-label">Sign:</div>
                <div class="sign-value" id="rightSign">-</div>
              </div>
              <div class="sign-row">
                <div class="sign-label">Ticket:</div>
                <div class="sign-value" id="rightTicket">-</div>
              </div>
              <div class="sign-row">
                <div class="sign-label">Disabled:</div>
                <div class="sign-value" id="rightDisabled">-</div>
              </div>
            </div>
          </div>
        </div>
        <!-- Timer Card Container -->
        <div id="timerCardContainer" class="timer-card-container">
          <div id="timerCard" class="card timer-card">
            <div class="timer-label">Time Until Reminder</div>
            <div id="warningTime" class="time-display">00:00:00</div>
            <div id="expiryTime" class="expires-at"></div>
          </div>
          <button id="stopTimerBtn">Stop Timer</button>
        </div>
        <!-- Action Buttons Container -->
        <div class="button-container">
          <button id="captureBtn" class="button primary-button">
            <svg
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M12 15C13.6569 15 15 13.6569 15 12C15 10.3431 13.6569 9 12 9C10.3431 9 9 10.3431 9 12C9 13.6569 10.3431 15 12 15Z"
                stroke="white"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
              <path
                d="M9 2L7.17 4H4C2.9 4 2 4.9 2 6V18C2 19.1 2.9 20 4 20H20C21.1 20 22 19.1 22 18V6C22 4.9 21.1 4 20 4H16.83L15 2H9Z"
                stroke="white"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </button>
          <button id="retakeBtn" class="button danger-button">
            <svg
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M4 4V9H4.58152M19.9381 11C19.446 7.05369 16.0796 4 12 4C8.64262 4 5.76829 6.06817 4.58152 9M4.58152 9H9M20 20V15H19.4185M19.4185 15C18.2317 17.9318 15.3574 20 12 20C7.92038 20 4.55399 16.9463 4.06189 13M19.4185 15H15"
                stroke="white"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
            Retake Photo
          </button>
        </div>
        <!-- AI Details Collapsible (Initially hidden by CSS) -->
        <div id="aiDetailsSection">
          <button class="collapsible">
            <span>Show AI Response Details</span>
            <svg
              class="chevron"
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M6 9L12 15L18 9"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </button>
          <div class="content">
            <pre class="ai-response" id="originalText"></pre>
          </div>
        </div>
      </div>
      <!-- End Main Content -->

      <!-- Bottom Navigation -->
      <nav class="bottom-nav">
        <button
          class="nav-btn active"
          id="navStatusBtn"
          aria-label="Current Status"
        >
          <svg
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M10 21H14C14 21.5523 13.5523 22 13 22H11C10.4477 22 10 21.5523 10 21Z"
              fill="currentColor"
            />
            <path
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M12 2C6.47715 2 2 6.47715 2 12C2 16.858 5.41123 20.7745 10 21.7225V21H14V21.7225C18.5888 20.7745 22 16.858 22 12C22 6.47715 17.5228 2 12 2ZM10.1455 15.0585C10.4079 15.4705 10.876 15.7135 11.3797 15.7135H12.6107C13.1144 15.7135 13.5825 15.4705 13.8449 15.0585L15.1609 12.9875L16.7529 12.0205C17.0999 11.8065 17.2499 11.3715 17.0909 10.9945C16.9339 10.6185 16.5299 10.4145 16.1349 10.5115L14.2009 11.0095L13.2829 9.5075C13.1049 9.2305 12.7839 9.0705 12.4339 9.0705H11.5569C11.2069 9.0705 10.8859 9.2305 10.7079 9.5075L9.7899 11.0095L7.8559 10.5115C7.4609 10.4145 7.0569 10.6185 6.8999 10.9945C6.7409 11.3715 6.8909 11.8065 7.2379 12.0205L8.8299 12.9875L10.1455 15.0585Z"
              fill="currentColor"
            />
          </svg>
          <span>Status</span>
        </button>
        <button class="nav-btn" id="navHistoryBtn" aria-label="Parking History">
          <svg
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M12 8V12L15 15M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
          <span>History</span>
        </button>
        <button class="nav-btn" id="navSettingsBtn" aria-label="Settings">
          <svg
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M4 21V14M4 10V3M12 21V12M12 8V3M20 21V16M20 12V3M1 14H7M9 8H15M17 16H23"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
          <span>Settings</span>
        </button>
      </nav>

      <!-- Status Message Area -->
      <div id="status" class="status-message"></div>
    </div>
    <!-- End App Container -->

    <!-- Modals -->
    <div id="signSelectionModal" class="modal">
      <div class="modal-content">
        <div class="modal-title">Which side did you park on?</div>
        <div class="modal-buttons">
          <button id="leftSignBtn" class="button primary-button modal-button">
            Left Side
          </button>
          <button id="rightSignBtn" class="button primary-button modal-button">
            Right Side
          </button>
        </div>
      </div>
    </div>
    <div id="ticketTimeModal" class="modal">
      <div class="modal-content">
        <div class="modal-title">Ticket Required: Select Parking Duration</div>
        <p
          style="
            text-align: center;
            font-size: 14px;
            color: var(--text-light);
            margin-bottom: 15px;
          "
        >
          Choose how long you plan to park.
        </p>
        <div id="ticket-time-options"></div>
        <button
          id="cancelTicketTimeBtn"
          class="button danger-button modal-button"
          style="margin-top: 20px"
        >
          Cancel
        </button>
      </div>
    </div>
    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
      <div class="modal-content">
        <button class="modal-close-btn" id="closeSettingsBtn">×</button>
        <div class="modal-title">Settings</div>
        <div class="settings-section">
          <h3>Appearance</h3>
          <div class="setting-item">
            <label for="darkModeToggle">Dark Mode</label
            ><label class="toggle-switch"
              ><input type="checkbox" id="darkModeToggle" /><span
                class="slider"
              ></span
            ></label>
          </div>
        </div>
        <div class="settings-section">
          <h3>Accessibility</h3>
          <div class="setting-item">
            <label for="disabilityToggle">Disability Permit</label
            ><label class="toggle-switch"
              ><input type="checkbox" id="disabilityToggle" /><span
                class="slider"
              ></span
            ></label>
          </div>
          <p style="font-size: 12px; color: var(--text-light); margin-top: 5px">
            Enable if you have a valid permit.
          </p>
        </div>
        <div class="settings-section">
          <h3>Advanced</h3>
          <div class="setting-item">
            <label for="showAiDetailsToggle">Show AI Response Details</label
            ><label class="toggle-switch"
              ><input type="checkbox" id="showAiDetailsToggle" /><span
                class="slider"
              ></span
            ></label>
          </div>
          <p style="font-size: 12px; color: var(--text-light); margin-top: 5px">
            Display the raw text output from the AI after analysis.
          </p>
        </div>
        <div class="settings-section">
          <h3>About</h3>

          <p style="font-size: 10px; color: var(--text-light)">
            Version: 10.1 (Google Maps button) - Last updated: April 27, 2025
          </p>
          <br/>
          <p style="font-size: 10px; color: var(--text-light)">
            Made with ❤️ by KH @
            <a
              href="https://shorturl.at/v8TYg"
              target="_blank"
              style="color: var(--primary)"
            >
              Shellcraft
            </a>
          </p>
          <br />
          <a
            href="mailto:2uh114cu@duck.com"
            target="_blank"
            style="
              color: var(--primary);
              text-decoration: underline;
              font-size: 10px;
              display: block;
              margin-bottom: 10px;
            "
            >Questions? Suggestions? Click here!</a
          >
          <br />
          <a
            href="https://parkease.glitch.me/terms.html"
            target="_blank"
            style="
              color: var(--primary);
              text-decoration: underline;
              font-size: 10px;
              display: block;
              margin-bottom: 10px;
            "
            >View Terms and Conditions</a
          >
          <a href="https://www.free-counters.org/"
            ></a
          >
          <script
            type="text/javascript"
            src="https://www.freevisitorcounters.com/auth.php?id=b7a7f79d3b71b08a61b248cf877286d65dec3075"
          ></script>
          <script
            type="text/javascript"
            src="https://www.freevisitorcounters.com/en/home/counter/1324179/t/1"
          ></script>
        </div>
      </div>
    </div>
    <!-- History Modal -->
    <div id="historyModal" class="modal">
      <div class="modal-content">
        <button class="modal-close-btn" id="closeHistoryModalBtn">×</button>
        <div class="modal-title">Parking History</div>
        <ul id="history-list">
          <li style="text-align: center; color: var(--text-light)">
            Loading history...
          </li>
        </ul>
        <button
          id="clearHistoryBtn"
          class="button danger-button modal-button"
          style="font-size: 12px; padding: 8px; margin-top: 15px"
        >
          Clear History
        </button>
      </div>
    </div>
    <!-- History Detail Modal -->
    <div id="historyDetailModal" class="modal">
      <div class="modal-content">
        <button class="modal-close-btn" id="closeHistoryDetailBtn">×</button>
        <div class="modal-title">Parking Session Details</div>
        <div id="history-detail-map"></div>
        <!-- Google Maps Button (History) -->
        <div
          id="openMapBtnContainerHistory"
          style="
            text-align: center;
            display: none;
            margin-top: 10px;
            margin-bottom: 10px;
          "
        >
          <button id="openMapBtnHistory" class="button map-button">
            <svg
              width="16"
              height="16"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
              style="margin-right: 6px"
            >
              <path
                d="M21 10C21 17 12 23 12 23C12 23 3 17 3 10C3 7.61305 3.94821 5.32387 5.63604 3.63604C7.32387 1.94821 9.61305 1 12 1C14.3869 1 16.6761 1.94821 18.364 3.63604C20.0518 5.32387 21 7.61305 21 10Z"
                stroke="white"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
              <path
                d="M12 13C13.6569 13 15 11.6569 15 10C15 8.34315 13.6569 7 12 7C10.3431 7 9 8.34315 9 10C9 11.6569 10.3431 13 12 13Z"
                stroke="white"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
            Open in Google Maps
          </button>
        </div>
        <div id="history-detail-content"></div>
      </div>
    </div>

    <!-- Audio Elements -->
    <audio
      id="silentAudio"
      loop
      src="https://cdn.glitch.global/16c2e168-5f80-4256-858b-ebbfd77da240/5-seconds-of-silence.mp3?v=1739673346964"
    ></audio>
    <audio
      id="alarmAudio"
      loop
      src="https://cdn.glitch.global/16c2e168-5f80-4256-858b-ebbfd77da240/5-seconds-of-silence.mp3?v=1739673346964"
    ></audio>

    <!-- Leaflet JS -->
    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>

        <script>
      // --- DOM Elements ---
      const body = document.body;
      const installGate = document.getElementById("install-gate");
      const iosInstallPrompt = document.getElementById("ios-install-prompt");
      const androidInstallPrompt = document.getElementById(
        "android-install-prompt"
      );
      const otherOsPrompt = document.getElementById("other-os-prompt");
      const installBtnAndroid = document.getElementById("install-btn-android");
      const appContainer = document.querySelector(".app-container");
      const video = document.getElementById("video");
      const canvas = document.getElementById("canvas");
      const capturedImage = document.getElementById("capturedImage");
      const captureBtn = document.getElementById("captureBtn");
      const retakeBtn = document.getElementById("retakeBtn");
      const status = document.getElementById("status");
      const timerCardContainer = document.getElementById("timerCardContainer");
      const timerCard = document.getElementById("timerCard");
      const warningTimeEl = document.getElementById("warningTime");
      const expiryTimeEl = document.getElementById("expiryTime");
      const stopTimerBtn = document.getElementById("stopTimerBtn");
      const silentAudio = document.getElementById("silentAudio");
      const alarmAudio = document.getElementById("alarmAudio");
      const originalText = document.getElementById("originalText");
      const aiDetailsSection = document.getElementById("aiDetailsSection");
      const signSelectionModal = document.getElementById("signSelectionModal");
      const leftSignBtn = document.getElementById("leftSignBtn");
      const rightSignBtn = document.getElementById("rightSignBtn");
      const ticketTimeModal = document.getElementById("ticketTimeModal");
      const ticketTimeOptionsContainer = document.getElementById(
        "ticket-time-options"
      );
      const cancelTicketTimeBtn = document.getElementById(
        "cancelTicketTimeBtn"
      );
      const signGraphs = document.getElementById("signGraphs");
      const settingsModal = document.getElementById("settingsModal");
      const closeSettingsBtn = document.getElementById("closeSettingsBtn");
      const darkModeToggle = document.getElementById("darkModeToggle");
      const disabilityToggle = document.getElementById("disabilityToggle");
      const showAiDetailsToggle = document.getElementById(
        "showAiDetailsToggle"
      );
      const historyModal = document.getElementById("historyModal");
      const closeHistoryModalBtn = document.getElementById(
        "closeHistoryModalBtn"
      );
      const historyList = document.getElementById("history-list");
      const clearHistoryBtn = document.getElementById("clearHistoryBtn");
      const historyDetailModal = document.getElementById("historyDetailModal");
      const closeHistoryDetailBtn = document.getElementById(
        "closeHistoryDetailBtn"
      );
      const historyDetailMapEl = document.getElementById("history-detail-map");
      const historyDetailContent = document.getElementById(
        "history-detail-content"
      );
      const cameraSection = document.getElementById("camera-section");
      const mapSection = document.getElementById("map-section");
      const mapEl = document.getElementById("map");
      const navStatusBtn = document.getElementById("navStatusBtn");
      const navHistoryBtn = document.getElementById("navHistoryBtn");
      const navSettingsBtn = document.getElementById("navSettingsBtn");
      const allNavBtns = document.querySelectorAll(".nav-btn");
      const leftSignHeader = document.getElementById("leftSignHeader");
      const leftTime = document.getElementById("leftTime");
      const leftSign = document.getElementById("leftSign");
      const leftTicket = document.getElementById("leftTicket");
      const leftDisabled = document.getElementById("leftDisabled");
      const rightSignHeader = document.getElementById("rightSignHeader");
      const rightTime = document.getElementById("rightTime");
      const rightSign = document.getElementById("rightSign");
      const rightTicket = document.getElementById("rightTicket");
      const rightDisabled = document.getElementById("rightDisabled");

      // --- NEW Elements for Google Maps Button ---
      const openMapBtnContainerMain = document.getElementById("openMapBtnContainerMain");
      const openMapBtnMain = document.getElementById("openMapBtnMain");
      const openMapBtnContainerHistory = document.getElementById("openMapBtnContainerHistory");
      const openMapBtnHistory = document.getElementById("openMapBtnHistory");
      // --- End NEW Elements ---

      // --- State Variables ---
      let deferredPrompt;
      let videoStream = null;
      let timersActive = false;
      let timerIntervals = [];
      let statusTimeout = null;
      let currentParkingSession = {};
      let map = null;
      let currentUserLocationMarker = null;
      let savedLocationMarker = null;
      let currentCoords = null;
      let watchId = null;
      let historyDetailMap = null;
      let alarmHasTriggered = false;
      let currentApiKeyIndex = 0; // Index for rotating API keys

      // --- Constants ---
      // !!! IMPORTANT: Replace placeholders with your actual API keys !!!
      const GEMINI_API_KEYS = [
        "AIzaSyC9ldLgyHQpE3H35vtm8Nxpp-9pTYihPdc",
        "AIzaSyDLE81P8wgkVDgR4wukGUhuXBDEPA14nWM",
        "AIzaSyCrCOrO0OAXR-X_kNtKy0Dg8sCugHqirZ4",
        "AIzaSyC6G_ZBPZD3gKjWCZ8YkvEuYv8pLBjn2Sw",
        // Add more keys if you have them
      ];

      const GEMINI_PROMPT = `Take a deep breath and look at the image provided.
For each parking sign(s) provided, return the following sections in order:

1. List All Visible Parking Signs
Include the sign details and the arrow direction (Left, Right, Both(which includes no arrows)).
Format:
 [Arrow Direction] Sign (#) - Time: [Minutes/unlimited/no parking] -- Sign it is referring to: [Sign details] -- Ticket: [Yes/No] -- Disabled: [Yes/No]

2. Determine Which Sign Applies Based on Current Time & Day
Current time: ${new Date().toLocaleString()}
Current day: ${new Date().toLocaleDateString("en-US", { weekday: "long" })}
If there are multiple signs that covers different time slots, use the one that applies to the current time.
If no sign is valid for the current time and there are no other restrictions, return "unlimited".
If there is a sign with “free parking” and another sign in the same time slot, the free parking applies.

3. Convert Parking Time to Minutes
"2P" → 120
"3P" → 180
"4P" → 240
"No Parking" / "No Stopping" / "Clearway" / "Zones, like Mail Zone, Police, etc" if it is in that time slot (or no time slot) → "no parking"
If no parking signs apply, return "unlimited"

4. Handle Ticket/Metered Parking
If the sign includes "ticket" or "meter" or any thing that indicates paid parking, return "Yes" for the Ticket field.

5. Handle Disability Parking
If the sign is a disabled parking sign, return "Yes" for the Disabled field and "no parking" for the Time field.

6. Return Final Left & Right Signs
For each side of the pole, based on the current time and the parking signs you listed out, determine the times the parking sign applies return the FINAL Left Sign and FINAL Right Sign in this format (even if the sign applies to both sides, still return both sides.):
 FINAL Left Sign - Time: [Minutes/unlimited/no parking] -- Sign Used: [Sign details] -- Reason: [Why you think this parking sign applies] -- Ticket: [Yes/No] -- Disabled: [Yes/No]
 FINAL Right Sign - Time: [Minutes/unlimited/no parking] -- Sign Used: [Sign details] -- Reason: [Why you think this parking sign applies] -- Ticket: [Yes/No] -- Disabled: [Yes/No]

IMPORTANT Clarifications:
Only Three Possible Arrow Directions:
Left Arrow → Only affects the left side of the pole.
Right Arrow → Only affects the right side of the pole.
Both Arrows → Applies to both sides, meaning there should be NO separate Left or Right sign interpretations—just one sign applying to both.

Example Scenarios & Expected Output for your better understanding:

Scenario 1
Signs:
Left Arrow: "2P Mon-Fri 1pm-6pm"
Left Arrow: "3P Mon-Fri 6am-1pm"
Right Arrow: "4P Sat-Sun"
Current Time: Monday 1:50pm
Expected Output:
FINAL Left Sign - Time: 120 -- Sign Used: Mon-Fri 1pm-6pm -- Reason: It is in that time slot -- Ticket: No -- Disabled: No
FINAL Right Sign - Time: unlimited -- Sign Used: None -- Reason: It is not in any sign’s time slot -- Ticket: No -- Disabled: No

Scenario 2
Signs:
Left Arrow: "2P Mon-Fri 1pm-6pm ticket"
Right Arrow: "3P Mon-Fri 6am-1pm"
Current Time: Monday 12:30pm
Expected Output:
FINAL Left Sign - Time: unlimited -- Sign Used: None -- Reason: It is not in any sign’s time slot -- Ticket: No -- Disabled: No
FINAL Right Sign - Time: 180 -- Sign Used: Mon-Fri 6am-1pm -- Reason: It is in that time slot -- Ticket: No -- Disabled: No

Scenario 3
Signs:
Left Arrow: "No Stopping"
Right Arrow: "2P Mon-Fri 1pm-6pm"
Current Time: Tuesday 3pm
Expected Output:
FINAL Left Sign - Time: no parking -- Sign Used: No Stopping -- Reason: No parking allowed -- Ticket: No -- Disabled: No
FINAL Right Sign - Time: 120 -- Sign Used: Mon-Fri 1pm-6pm -- Reason: It is in that time slot -- Ticket: No -- Disabled: No

Scenario 4
Signs:
Left Arrow: "3P Sat-Sun"
Right Arrow: "2P Mon-Fri 1pm-6pm"
Current Time: Wednesday 10am
Expected Output:
FINAL Left Sign - Time: unlimited -- Sign Used: None -- Reason: It is not in any sign’s time slot -- Ticket: No -- Disabled: No
FINAL Right Sign - Time: unlimited -- Sign Used: None -- Reason: It is not in any sign’s time slot -- Ticket: No -- Disabled: No

Scenario 5
Signs:
Left Arrow: "Mail Zone All Other Times"
Right Arrow: "2P Mon-Fri 1pm-6pm"
Current Time: Tuesday 3pm
Expected Output:
FINAL Left Sign - Time: no parking -- Sign Used: Mail Zone -- Reason: No parking allowed -- Ticket: No -- Disabled: No
FINAL Right Sign - Time: 120 -- Sign Used: Mon-Fri 1pm-6pm -- Reason: It is in that time slot -- Ticket: No -- Disabled: No


Scenario 6: Multiple Signs on Both Sides (Metered Parking)
Signs:
Left Arrow:
"3P Mon-Fri 6am-1pm"
"2P Mon-Fri 1pm-6pm"
"4P Sat-Sun"
 Right Arrow:
"No Parking Mon-Fri 7am-9am"
"2P Mon-Fri 9am-6pm ticket"
"4P Sat-Sun ticket"
 Current Time: Monday, 10:30am
Expected Output:
FINAL Left Sign - Time: 180 -- Sign Used: Mon-Fri 6am-1pm -- Reason: It is in that time slot -- Ticket: No -- Disabled: No
FINAL Right Sign - Time: 120 -- Sign Used: Mon-Fri 9am-6pm ticket -- Reason: It is in that time slot -- Ticket: Yes -- Disabled: No

Scenario 7: Sign with Both Arrows (Applies to Both Sides)
Signs:
Sign with Both Arrows: "3P"
Current Time: Any
Expected Output:
FINAL Left Sign - Time: 180 -- Sign Used: 3P -- Reason: It is in the sign’s time slot -- Ticket: No -- Disabled: No
FINAL Right Sign - Time: 180 -- Sign Used: 3P -- Reason: It is in the sign’s time slot -- Ticket: No -- Disabled: No

And to remind you again, the current time is:
Current time: ${new Date().toLocaleString()}
Current day: ${new Date().toLocaleDateString("en-US", { weekday: "long" })}


Thank you so much!`;

      // --- LocalStorage Helpers ---
      function getLocalStorage(key, defaultValue) {
        try {
          const v = localStorage.getItem(key);
          return v === null ? defaultValue : JSON.parse(v);
        } catch (e) {
          console.error(`LS Get Error [${key}]`, e);
          return defaultValue;
        }
      }
      function setLocalStorage(key, value) {
        try {
          localStorage.setItem(key, JSON.stringify(value));
        } catch (e) {
          console.error(`LS Set Error [${key}]`, e);
          showStatus("Error saving data.");
        }
      }

      // --- Settings ---
      let settings = {
        darkMode: getLocalStorage("parkEaseSettings_darkMode", false),
        disabilityPermit: getLocalStorage(
          "parkEaseSettings_disabilityPermit",
          false
        ),
        showAiDetails: getLocalStorage("parkEaseSettings_showAiDetails", false),
      };
      let parkingHistory = getLocalStorage("parkEaseHistory", []);
      function applyTheme(isDark) {
        body.classList.toggle("dark-mode", isDark);
        document
          .querySelector('meta[name="theme-color"]')
          .setAttribute("content", isDark ? "#0d1117" : "#4a90e2");
        settings.darkMode = isDark;
        setLocalStorage("parkEaseSettings_darkMode", isDark);
      }
      function applyDisability(hasPermit) {
        settings.disabilityPermit = hasPermit;
        setLocalStorage("parkEaseSettings_disabilityPermit", hasPermit);
        showStatus(
          `Disability Permit ${
            hasPermit ? "Enabled" : "Disabled"
          }. Retake photo if needed.`,
          3000
        );
      }
      function applyShowAiDetails(show) {
        settings.showAiDetails = show;
        setLocalStorage("parkEaseSettings_showAiDetails", show);
        const analysisDone =
          originalText.textContent &&
          originalText.textContent !== "Sending request to AI...";
        aiDetailsSection.style.display =
          show && analysisDone ? "block" : "none";
      }
      function renderHistory() {
        const listElement = document.getElementById("history-list");
        listElement.innerHTML = "";
        if (parkingHistory.length === 0) {
          listElement.innerHTML =
            '<li style="text-align: center; color: var(--text-light); background: none; border: none; cursor: default;">No history yet.</li>';
          clearHistoryBtn.style.display = "none";
          return;
        }
        clearHistoryBtn.style.display = "block";
        const sortedHistory = [...parkingHistory].sort(
          (a, b) => b.timestamp - a.timestamp
        );
        sortedHistory.forEach((item, index) => {
          const li = document.createElement("li");
          li.classList.add("history-entry");
          li.dataset.index = parkingHistory.findIndex(
            (h) => h.timestamp === item.timestamp
          );
          const date = new Date(item.timestamp);
          const formattedDate = date.toLocaleDateString(undefined, {
            year: "numeric",
            month: "short",
            day: "numeric",
          });
          const formattedTime = date.toLocaleTimeString(undefined, {
            hour: "numeric",
            minute: "2-digit",
          });
          li.innerHTML = `<span class="date">${formattedDate} at ${formattedTime}</span><span class="details">Rule: ${
            item.rule
          } ${
            item.location
              ? `(${item.location.lat.toFixed(3)}, ${item.location.lng.toFixed(
                  3
                )})`
              : ""
          }</span>`;
          li.addEventListener("click", () => {
            historyModal.classList.remove("visible");
            setActiveNav(navStatusBtn);
            showHistoryDetail(li.dataset.index);
          });
          listElement.appendChild(li);
        });
      }
      function saveParkingSession(sessionData) {
        if (!sessionData.timestamp) {
          sessionData.timestamp = Date.now();
        }
        parkingHistory.push(sessionData);
        setLocalStorage("parkEaseHistory", parkingHistory);
      }
      function clearHistory() {
        if (confirm("Clear all parking history?")) {
          parkingHistory = [];
          setLocalStorage("parkEaseHistory", parkingHistory);
          renderHistory();
          showStatus("Parking history cleared.");
        }
      }

      // --- MODIFIED showHistoryDetail Function ---
      function showHistoryDetail(index) {
        const item = parkingHistory[index];
        if (!item) return;

        // --- Reset history button state ---
        openMapBtnContainerHistory.style.display = 'none';
        delete openMapBtnHistory.dataset.lat; // Clear previous data
        delete openMapBtnHistory.dataset.lng;
        // --- End Reset ---

        historyDetailContent.innerHTML = `<p><strong>Date:</strong> ${new Date(
          item.timestamp
        ).toLocaleString()}</p><p><strong>Interpreted Rule:</strong> ${
          item.rule
        }</p><p><strong>Sign Analysis:</strong></p>
                <pre style="font-size: 11px; background: var(--background); padding: 8px; border-radius: 6px; border: 1px solid var(--gray); max-height: 150px; overflow-y: auto; white-space: pre-wrap; word-break: break-all;">${
                  item.signInterpretation || "N/A"
                }</pre>
                ${
                  item.location
                    ? `<p><strong>Location:</strong> Lat: ${item.location.lat.toFixed(
                        5
                      )}, Lng: ${item.location.lng.toFixed(5)}</p>`
                    : "<p>Location not recorded.</p>"
                }`;

        historyDetailModal.classList.add("visible");

        if (!historyDetailMap) {
          historyDetailMap = L.map(historyDetailMapEl);
          L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            maxZoom: 19,
            attribution: "© OpenStreetMap",
          }).addTo(historyDetailMap);
        }

        if (item.location) {
          historyDetailMapEl.style.display = "block";
          const coords = L.latLng(item.location.lat, item.location.lng);
          historyDetailMap.setView(coords, 16);
          historyDetailMap.eachLayer((layer) => {
            if (layer instanceof L.Marker) historyDetailMap.removeLayer(layer);
          });
          L.marker(coords)
            .addTo(historyDetailMap)
            .bindPopup("Parked Location")
            .openPopup();

          // --- Show history button and store coords ---
          openMapBtnHistory.dataset.lat = item.location.lat;
          openMapBtnHistory.dataset.lng = item.location.lng;
          openMapBtnContainerHistory.style.display = 'block';
          // --- End Show Button ---

          setTimeout(() => {
            try {
              historyDetailMap.invalidateSize();
            } catch (e) {}
          }, 150);
        } else {
          historyDetailMapEl.style.display = "none";
          openMapBtnContainerHistory.style.display = 'none'; // Ensure hidden if no location
        }
      }

      // --- Check if Running as PWA ---
      function isRunningStandalone() {
        return (
          window.matchMedia("(display-mode: standalone)").matches ||
          window.navigator.standalone
        );
      }

      // --- Initialization Control ---
      function checkInstallationAndInitialize() {
        console.log("Checking installation status...");
        applyTheme(settings.darkMode);
        if (isRunningStandalone()) {
          console.log("Running in standalone mode.");
          installGate.style.display = "none";
          initializeAppCore();
        } else {
          console.log("Running in browser.");
          installGate.style.display = "flex";
          detectOSAndShowInstructions();
        }
      }

      // --- Core App Initialization (Called ONLY if installed) ---
      // --- MODIFIED initializeAppCore Function ---
      function initializeAppCore() {
        console.log("Initializing core app features...");
        disabilityToggle.checked = settings.disabilityPermit;
        showAiDetailsToggle.checked = settings.showAiDetails;
        applyShowAiDetails(settings.showAiDetails);
        initCamera();
        initMap();
        captureBtn.addEventListener("click", handleCapture);
        retakeBtn.addEventListener("click", handleRetake);
        navStatusBtn.addEventListener("click", () => {
          setActiveNav(navStatusBtn);
          settingsModal.classList.remove("visible");
          historyModal.classList.remove("visible");
          document.querySelector(".main-content").scrollTop = 0;
        });
        navHistoryBtn.addEventListener("click", () => {
          setActiveNav(navHistoryBtn);
          settingsModal.classList.remove("visible");
          renderHistory();
          historyModal.classList.add("visible");
        });
        navSettingsBtn.addEventListener("click", () => {
          setActiveNav(navSettingsBtn);
          historyModal.classList.remove("visible");
          settingsModal.classList.add("visible");
          document.querySelector("#settingsModal .modal-content").scrollTop = 0;
        });
        closeSettingsBtn.addEventListener("click", () => {
          settingsModal.classList.remove("visible");
          setActiveNav(navStatusBtn);
        });
        closeHistoryModalBtn.addEventListener("click", () => {
          historyModal.classList.remove("visible");
          setActiveNav(navStatusBtn);
        });
        closeHistoryDetailBtn.addEventListener("click", () =>
          historyDetailModal.classList.remove("visible")
        );
        darkModeToggle.addEventListener("change", (e) =>
          applyTheme(e.target.checked)
        );
        disabilityToggle.addEventListener("change", (e) =>
          applyDisability(e.target.checked)
        );
        showAiDetailsToggle.addEventListener("change", (e) =>
          applyShowAiDetails(e.target.checked)
        );
        clearHistoryBtn.addEventListener("click", clearHistory);
        cancelTicketTimeBtn.addEventListener("click", () =>
          ticketTimeModal.classList.remove("visible")
        );
        stopTimerBtn.addEventListener("click", handleStopTimer);
        const coll = document.getElementsByClassName("collapsible");
        if (coll.length > 0) {
          coll[0].addEventListener("click", function () {
            this.classList.toggle("active");
            const content = this.nextElementSibling;
            if (content.style.maxHeight) {
              content.style.maxHeight = null;
            } else {
              content.style.display = "block"; // Make sure it's visible before calculating height
              requestAnimationFrame(() => { // Use requestAnimationFrame for smoother transitions
                requestAnimationFrame(() => {
                    content.style.maxHeight = content.scrollHeight + "px";
                });
              });
            }
          });
        }
        window.addEventListener("click", (e) => {
          const closeAndResetNav = () => setActiveNav(navStatusBtn);
          if (e.target === settingsModal) {
            settingsModal.classList.remove("visible");
            closeAndResetNav();
          }
          if (e.target === historyModal) {
            historyModal.classList.remove("visible");
            closeAndResetNav();
          }
          if (e.target === signSelectionModal)
            signSelectionModal.classList.remove("visible");
          if (e.target === ticketTimeModal)
            ticketTimeModal.classList.remove("visible");
          if (e.target === historyDetailModal)
            historyDetailModal.classList.remove("visible");
        });

        // --- Add Google Maps button listeners ---
        openMapBtnMain.addEventListener('click', () => {
            const lat = openMapBtnMain.dataset.lat;
            const lng = openMapBtnMain.dataset.lng;
            if (lat && lng) {
                // Use Google Maps URL scheme
                const url = `https://www.google.com/maps/search/?api=1&query=${lat},${lng}`;
                window.open(url, '_blank'); // Open in new tab/window
            } else {
                showStatus("Location data missing for map link.", 2000);
            }
        });

        openMapBtnHistory.addEventListener('click', () => {
            const lat = openMapBtnHistory.dataset.lat;
            const lng = openMapBtnHistory.dataset.lng;
            if (lat && lng) {
                // Use Google Maps URL scheme
                const url = `https://www.google.com/maps/search/?api=1&query=${lat},${lng}`;
                window.open(url, '_blank'); // Open in new tab/window
            } else {
                showStatus("Location data missing for map link.", 2000);
            }
        });
        // --- End Google Maps button listeners ---

        setActiveNav(navStatusBtn);
        console.log("Core app initialized.");
      }

      // --- OS Detection and Install Prompt Logic ---
      function detectOSAndShowInstructions() {
        const ua = navigator.userAgent;
        const isIOS =
          /iPad|iPhone|iPod/.test(ua) ||
          (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
        const isAndroid = /Android/.test(ua);
        console.log(`OS Detection: iOS=${isIOS}, Android=${isAndroid}`);
        iosInstallPrompt.style.display = "none";
        androidInstallPrompt.style.display = "none";
        otherOsPrompt.style.display = "none";
        if (isIOS) {
          console.log("Showing iOS instructions.");
          iosInstallPrompt.style.display = "block";
        } else if (isAndroid) {
          console.log("Showing Android instructions.");
          androidInstallPrompt.style.display = "block";
          installBtnAndroid.disabled = true;
          installBtnAndroid.textContent = "Checking..."; // Wait for beforeinstallprompt
        } else {
          console.log("Showing fallback instructions.");
          otherOsPrompt.style.display = "block";
        }
      }

      // --- Bottom Nav Helper ---
      function setActiveNav(activeBtn) {
        allNavBtns.forEach((btn) => btn.classList.remove("active"));
        if (activeBtn) activeBtn.classList.add("active");
      }

      // --- Camera ---
      async function initCamera() {
        try {
          videoStream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "environment" },
          });
          video.srcObject = videoStream;
          video.style.display = "block";
          capturedImage.style.display = "none";
          cameraSection.style.display = "block";
          mapSection.style.display = "none"; // Ensure map is hidden when camera starts
          openMapBtnContainerMain.style.display = 'none'; // Ensure map button is hidden too
        } catch (err) {
          showStatus("Error accessing camera: " + err.message, 5000);
          console.error("Camera Error:", err);
        }
      }
      function stopCamera() {
        if (videoStream) {
          videoStream.getTracks().forEach((track) => track.stop());
          video.srcObject = null;
          videoStream = null;
        }
      }

      // --- Map ---
      function initMap() {
        map = L.map(mapEl).setView([0, 0], 2);
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          maxZoom: 19,
          attribution: "© OpenStreetMap contributors",
        }).addTo(map);
        const currentLocationIcon = L.divIcon({
          className: "current-location-marker",
          iconSize: [16, 16],
        });
        if ("geolocation" in navigator) {
          watchId = navigator.geolocation.watchPosition(
            (position) => {
              currentCoords = L.latLng(
                position.coords.latitude,
                position.coords.longitude
              );
              if (!currentUserLocationMarker) {
                currentUserLocationMarker = L.marker(currentCoords, {
                  icon: currentLocationIcon,
                })
                  .addTo(map)
                  .bindPopup("You are here");
                if (!map.hasLayer(savedLocationMarker)) // Only zoom if no parked location shown
                  map.setView(currentCoords, 16);
              } else {
                currentUserLocationMarker.setLatLng(currentCoords);
              }
              // Auto-adjust view if map is visible and we have both markers
              if (mapSection.style.display === "block" && savedLocationMarker && currentUserLocationMarker) {
                   map.fitBounds(
                     L.latLngBounds(
                       savedLocationMarker.getLatLng(), // Use saved location
                       currentUserLocationMarker.getLatLng()
                     ),
                     { padding: [40, 40], maxZoom: 17 }
                   );
              }
              // Only pan to current if map is visible and no saved marker yet
              else if ( mapSection.style.display === "block" && !savedLocationMarker ) {
                 map.setView(currentCoords, 16);
              }

            },
            (error) => {
              console.error("Geolocation error:", error);
              showStatus("Could not get location.", 3000);
              if (
                !map.hasLayer(currentUserLocationMarker) &&
                !map.hasLayer(savedLocationMarker)
              ) // If no markers at all, set default view
                map.setView([40.7128, -74.006], 10); // Example: NYC
            },
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
          );
        } else {
          showStatus("Geolocation is not supported.", 5000);
          map.setView([40.7128, -74.006], 10); // Example: NYC
        }
      }

      // --- MODIFIED showMapAtParkedLocation Function ---
      function showMapAtParkedLocation() {
        mapSection.style.display = "block";
        cameraSection.style.display = "none";
        openMapBtnContainerMain.style.display = "none"; // Hide initially

        setTimeout(() => {
          if (map) {
            try {
              map.invalidateSize();
            } catch (e) {}

            if (currentCoords) { // Check if we have coords
              if (savedLocationMarker) map.removeLayer(savedLocationMarker);
              const savedLocationIcon = L.divIcon({
                className: "saved-location-marker",
                iconSize: [20, 20],
                iconAnchor: [10, 20],
              });
              savedLocationMarker = L.marker(currentCoords, {
                icon: savedLocationIcon,
              })
                .addTo(map)
                .bindPopup(
                  `<b>Parked Here</b><br>${new Date().toLocaleTimeString()}`
                )
                .openPopup();

              currentParkingSession.location = {
                lat: currentCoords.lat,
                lng: currentCoords.lng,
              };

              // Store coords on the main button for its click handler
              openMapBtnMain.dataset.lat = currentCoords.lat;
              openMapBtnMain.dataset.lng = currentCoords.lng;
              openMapBtnContainerMain.style.display = 'block'; // Show the button

              if (currentUserLocationMarker)
                map.fitBounds(
                  L.latLngBounds(
                    currentCoords, // The newly parked location
                    currentUserLocationMarker.getLatLng() // Current live location
                  ),
                  { padding: [40, 40], maxZoom: 17 }
                );
              else map.setView(currentCoords, 16); // Zoom to parked location if no live location marker
            } else {
              showStatus("Location unknown, cannot mark on map or open.", 3000);
              openMapBtnContainerMain.style.display = 'none'; // Ensure button is hidden if no coords
            }
          }
        }, 100); // Delay to ensure map container is rendered
      }

      // --- Capture & Analysis ---
      function handleCapture() {
        if (!videoStream) {
          showStatus("Camera not ready.", 3000);
          return;
        }
        if (timersActive) {
          if (
            !confirm(
              "A timer is active. Starting a new session will stop the current timer. Continue?"
            )
          )
            return;
          stopTimers();
        }
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const context = canvas.getContext("2d");
        context.drawImage(video, 0, 0, canvas.width, canvas.height);
        const imageDataUrl = canvas.toDataURL("image/jpeg", 0.9);
        capturedImage.src = imageDataUrl;
        capturedImage.style.display = "block";
        video.style.display = "none";
        stopCamera();
        captureBtn.style.display = "none";
        retakeBtn.style.display = "flex";
        try {
          silentAudio.play().catch((e) => {}); // Keep background audio active attempt
          alarmAudio.play().catch((e) => {}); // Keep potential alarm audio channel active
        } catch (e) {}
        resetAnalysisAndTimer(); // Reset UI elements, hides map initially
        currentParkingSession = {}; // Reset session data
        showStatus("Analyzing sign...", 10000); // Long timeout for analysis
        analyzeImage(imageDataUrl); // Start AI analysis
        showMapAtParkedLocation(); // Show map AFTER capture
        setActiveNav(navStatusBtn); // Ensure Status tab is active
      }

      // --- MODIFIED handleRetake Function ---
      function handleRetake() {
        resetAnalysisAndTimer(); // This hides map section and button container
        stopTimers(); // Stop any active timers
        capturedImage.style.display = "none"; // Hide captured image
        video.style.display = "block"; // Show video feed
        captureBtn.style.display = "flex"; // Show capture button
        retakeBtn.style.display = "none"; // Hide retake button
        cameraSection.style.display = "block"; // Ensure camera section is visible

        if (savedLocationMarker) { // Remove the parked marker from the map
          map.removeLayer(savedLocationMarker);
          savedLocationMarker = null;
        }
        if (currentUserLocationMarker) // Pan back to current location if available
          map.setView(currentUserLocationMarker.getLatLng(), 16);

        silenceAlarm(); // Silence any active alarm
        initCamera(); // Re-initialize camera feed
        showStatus("Ready to capture."); // Update status message
        setActiveNav(navStatusBtn); // Ensure Status tab is active
      }

      // --- MODIFIED resetAnalysisAndTimer Function ---
      function resetAnalysisAndTimer() {
        // Reset sign graph UI
        updateSignGraph("left", "-", "-", false, false, false);
        updateSignGraph("right", "-", "-", false, false, false);
        leftSignHeader.className = "sign-header";
        leftSignHeader.textContent = "LEFT SIDE";
        rightSignHeader.className = "sign-header";
        rightSignHeader.textContent = "RIGHT SIDE";
        signGraphs.classList.remove("visible");

        // Reset timer UI
        timerCard.style.display = "none";
        timerCardContainer.style.display = "none"; // Hide the container
        stopTimerBtn.style.display = "none";
        warningTimeEl.classList.remove("pulse");
        warningTimeEl.textContent = "00:00:00";
        expiryTimeEl.textContent = "";

        // Reset AI details UI
        aiDetailsSection.style.display = "none"; // Hide section
        originalText.textContent = ""; // Clear text
        const collapsible = document.querySelector(".collapsible");
        if (collapsible) {
          collapsible.classList.remove("active"); // Close collapsible
          const content = collapsible.nextElementSibling;
          if (content) content.style.maxHeight = null; // Collapse content area
        }

        // Close modals
        signSelectionModal.classList.remove("visible");
        ticketTimeModal.classList.remove("visible");

        // --- Hide map and map button on reset ---
        mapSection.style.display = "none";
        openMapBtnContainerMain.style.display = 'none';
        // --- End Hide ---
      }

      // --- Analyze Image (with Key Rotation) ---
      async function analyzeImage(imageDataUrl) {
        // Check if keys array is valid
        const validKeys = GEMINI_API_KEYS.filter(
          (key) => key && !key.startsWith("YOUR_API_KEY") // Basic check
        );
        if (validKeys.length === 0) {
          showStatus("No valid API Keys configured.", 5000);
          originalText.textContent =
            "Error: API Keys not configured correctly in the script.";
          applyShowAiDetails(true); // Show section to display this specific error
          resetAnalysisAndTimer(); // Reset UI as analysis cannot proceed
          return;
        }

        const selectedApiKey = validKeys[currentApiKeyIndex % validKeys.length]; // Use modulo on valid keys length
        const GEMINI_URL_DYNAMIC = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${selectedApiKey}`; // Updated model
        console.log(
          `Using API Key index: ${currentApiKeyIndex % validKeys.length}`
        ); // Log which key index is used

        originalText.textContent = "Sending request to AI..."; // Update hidden text
        applyShowAiDetails(settings.showAiDetails); // Show if enabled

        try {
          const response = await fetch(GEMINI_URL_DYNAMIC, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              contents: [
                {
                  parts: [
                    { text: GEMINI_PROMPT },
                    {
                      inline_data: {
                        mime_type: "image/jpeg",
                        data: imageDataUrl.split(",")[1], // Base64 data
                      },
                    },
                  ],
                },
              ],
              // Optional: Add safety settings if needed
              // safetySettings: [
              //   { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
              //   // ... other categories
              // ],
               generationConfig: { // Optional: control output
                 temperature: 0.4, // Lower temperature for more deterministic results
                 // maxOutputTokens: 8192, // Default is high, adjust if needed
               }
            }),
          });

          if (!response.ok) {
             const errorBody = await response.text(); // Read response body for more details
             console.error("API Error Response Body:", errorBody);
             // Try to parse JSON if possible for structured error
             let errorMessage = `API request failed (${response.status})`;
             try {
                 const errorJson = JSON.parse(errorBody);
                 if (errorJson.error && errorJson.error.message) {
                     errorMessage += `: ${errorJson.error.message}`;
                 } else {
                      errorMessage += `: ${errorBody.substring(0, 100)}...`; // Truncate long errors
                 }
             } catch (parseError) {
                 errorMessage += `: ${errorBody.substring(0, 100)}...`; // Fallback if not JSON
             }
             throw new Error(errorMessage);
          }

          const result = await response.json();
          console.log("Gemini Raw Response:", result);

          // Check for explicit error field in the response
          if (result.error) {
            throw new Error(result.error.message || "API returned an error");
          }

          // Check finish reason for blocking or other issues
          if (
            result.candidates &&
            result.candidates[0].finishReason &&
            result.candidates[0].finishReason !== "STOP" &&
            result.candidates[0].finishReason !== "MAX_TOKENS" // Allow MAX_TOKENS as potentially partial result
          ) {
            const blockReason = result.candidates[0].finishReason;
            console.warn(`Analysis response issue. Reason: ${blockReason}`);
            // Check if there's any partial content even if blocked
            const partialText = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (partialText) {
                originalText.textContent = partialText + `\n\n[Warning: Response may be incomplete due to finish reason: ${blockReason}]`;
                showStatus(`Analysis may be incomplete (${blockReason}). Interpreting rules...`, 4000);
                handleSignResponse(partialText); // Attempt to process partial text
            } else {
                throw new Error(`Analysis blocked or failed (${blockReason}). No content returned.`);
            }

          }
          // Check if the expected text content exists
          else if (!result.candidates?.[0]?.content?.parts?.[0]?.text) {
            console.error("Unexpected API response structure:", result);
            // Check for prompt feedback if no content
             if (result.promptFeedback && result.promptFeedback.blockReason) {
                 throw new Error(`Analysis blocked due to prompt feedback: ${result.promptFeedback.blockReason}`);
             } else {
                 throw new Error("Unexpected API response structure: No text content found.");
             }
          }
          // Success case
          else {
              const text = result.candidates[0].content.parts[0].text;
              originalText.textContent = text; // Update hidden text
              applyShowAiDetails(settings.showAiDetails); // Ensure visibility based on settings
              showStatus("Analysis complete. Interpreting rules...", 3000);
              handleSignResponse(text); // Process the successful response
          }

        } catch (err) {
          console.error("Analysis error:", err);
          showStatus(`Analysis Error: ${err.message}`, 6000);
          originalText.textContent = `Error during analysis:\n${err.message}`;
          applyShowAiDetails(true); // Show error details
          resetAnalysisAndTimer(); // Reset UI after error
        } finally {
          // Rotate to the next key index for the *next* request
          currentApiKeyIndex = currentApiKeyIndex + 1; // Simple increment, modulo happens at selection
          console.log(
            `Next API key index will be: ${
              currentApiKeyIndex % (validKeys.length || 1) // Avoid division by zero if validKeys is empty (though checked earlier)
            }`
          );
        }
      }

      // --- Parse Sign Details --- (Unchanged)
      function parseSignDetails(match) {
        if (!match) return null;
        // Adjust regex indices based on the actual FINAL format in the prompt
        // Expected format: Time: [1] -- Sign Used: [2] -- Reason: [...] -- Ticket: [3] -- Disabled: [4]
        const timePart = match[1]?.trim() || "unknown";
        const signPart = match[2]?.trim() || "unknown";
        const ticketPart = match[3]?.trim().toLowerCase();
        const disabledPart = match[4]?.trim().toLowerCase();

        return {
          time: timePart,
          sign: signPart,
          requiresTicket: ticketPart === "yes",
          isDisabled: disabledPart === "yes",
        };
      }

      // --- Handle Sign Response --- (Adjusted Regex)
      function handleSignResponse(responseText) {
        try {
          // Updated Regex to be more robust and capture correctly, ignoring the Reason part for parsing
          const leftSignRegex = /FINAL\s+Left\s+Sign\s*-\s*Time:\s*(.*?)\s*--\s*Sign Used:\s*(.*?)\s*--\s*Reason:.*?--\s*Ticket:\s*(Yes|No)\s*--\s*Disabled:\s*(Yes|No)/is;
          const rightSignRegex = /FINAL\s+Right\s+Sign\s*-\s*Time:\s*(.*?)\s*--\s*Sign Used:\s*(.*?)\s*--\s*Reason:.*?--\s*Ticket:\s*(Yes|No)\s*--\s*Disabled:\s*(Yes|No)/is; // Added 's' flag for multiline

          const leftMatch = responseText.match(leftSignRegex);
          const rightMatch = responseText.match(rightSignRegex);

          const leftData = parseSignDetails(leftMatch);
          const rightData = parseSignDetails(rightMatch);

          console.log("Parsed Left:", leftData);
          console.log("Parsed Right:", rightData);

          if (!leftData && !rightData) {
             console.error("Could not parse FINAL sign details from response:", responseText);
             throw new Error("Could not extract parking rules from AI response.");
          }


          currentParkingSession.signInterpretation = responseText; // Save full interpretation
          signGraphs.classList.add("visible"); // Show the sign cards

          const hasDisabilityPermit = settings.disabilityPermit;

          // Determine effective allowance considering disability permit
          const isEffectivelyAllowedLeft = leftData &&
             ((leftData.time.toLowerCase() !== "no parking" && !leftData.isDisabled) || // Normal parking allowed
             (leftData.isDisabled && hasDisabilityPermit)); // Disabled spot and user has permit

          const isEffectivelyAllowedRight = rightData &&
             ((rightData.time.toLowerCase() !== "no parking" && !rightData.isDisabled) || // Normal parking allowed
             (rightData.isDisabled && hasDisabilityPermit)); // Disabled spot and user has permit

          // Special case: Disabled spot where AI said "no parking" but permit overrides
           const isDisabilityOverrideLeft = hasDisabilityPermit && leftData?.isDisabled && leftData?.time.toLowerCase() === "no parking";
           const isDisabilityOverrideRight = hasDisabilityPermit && rightData?.isDisabled && rightData?.time.toLowerCase() === "no parking";


          // Update UI graphs
          if (leftData) {
            updateSignGraph(
              "left",
              leftData.time,
              leftData.sign,
              leftData.requiresTicket,
              leftData.isDisabled,
              isEffectivelyAllowedLeft, // Pass effective allowance
              isDisabilityOverrideLeft // Pass override status
            );
          } else {
            updateSignGraph("left", "Unknown", "N/A", false, false, false); // Default if no left sign parsed
          }
          if (rightData) {
            updateSignGraph(
              "right",
              rightData.time,
              rightData.sign,
              rightData.requiresTicket,
              rightData.isDisabled,
              isEffectivelyAllowedRight, // Pass effective allowance
              isDisabilityOverrideRight // Pass override status
            );
          } else {
            updateSignGraph("right", "Unknown", "N/A", false, false, false); // Default if no right sign parsed
          }

          // Decide next step based on allowance
          if (isEffectivelyAllowedLeft && isEffectivelyAllowedRight) {
            // Both sides allowed, show modal to choose
            signSelectionModal.classList.add("visible");
            leftSignBtn.onclick = () => {
              signSelectionModal.classList.remove("visible");
              processParkingChoice(leftData, "Left", isDisabilityOverrideLeft);
            };
            rightSignBtn.onclick = () => {
              signSelectionModal.classList.remove("visible");
              processParkingChoice(rightData, "Right", isDisabilityOverrideRight);
            };
          } else if (isEffectivelyAllowedLeft) {
            showStatus("Parking possible on Left side.", 2000);
            processParkingChoice(leftData, "Left", isDisabilityOverrideLeft); // Process left side choice
          } else if (isEffectivelyAllowedRight) {
            showStatus("Parking possible on Right side.", 2000);
            processParkingChoice(rightData, "Right", isDisabilityOverrideRight); // Process right side choice
          } else {
            // Neither side is allowed (considering disability permit)
            showStatus("No parking allowed here based on signs.", 4000);
            currentParkingSession.rule = "No Parking Allowed";
            saveParkingSession(currentParkingSession); // Save the outcome
          }
        } catch (err) {
          console.error("Error handling sign response:", err);
          showStatus(`Error interpreting sign data: ${err.message}. Please retake.`, 5000);
          resetAnalysisAndTimer(); // Reset UI on error
        }
      }

      // --- processParkingChoice Function --- (Unchanged)
      function processParkingChoice(
        signData,
        side,
        isDisabilityOverride = false
      ) {
        if (!signData) {
          showStatus(`Error: Invalid sign data for ${side} side.`, 4000);
          return;
        }
        console.log(
          `Processing parking for ${side} side:`,
          signData,
          `Disability Override: ${isDisabilityOverride}`
        );
        currentParkingSession.side = side;
        currentParkingSession.signDetails = signData;
        currentParkingSession.isDisabilityParking = isDisabilityOverride || signData.isDisabled; // Mark if it's a disability spot OR an override

        // Determine the effective time limit, considering disability override
        let effectiveTime = isDisabilityOverride ? "unlimited" : signData.time;

        // If ticket is required AND it's NOT a disability permit override
        if (signData.requiresTicket && !isDisabilityOverride) {
          showTicketTimeSelection(effectiveTime, side); // Show options based on sign's limit
        } else {
          // If no ticket needed OR it's a disability override (usually unlimited or free)
          handleTimeSelection(
            effectiveTime, // Use the potentially overridden time ("unlimited")
            side,
            signData.requiresTicket && !isDisabilityOverride // Still pass original ticket status for logging/history
          );
        }
      }

      // --- showTicketTimeSelection Function --- (Unchanged)
       function showTicketTimeSelection(maxTimeStr, side) {
        ticketTimeOptionsContainer.innerHTML = ""; // Clear previous options
        let maxMinutes = null;

        // Determine max duration from the sign string
        if (
          maxTimeStr &&
          maxTimeStr.toLowerCase() !== "unlimited" &&
          !isNaN(parseInt(maxTimeStr))
        ) {
          maxMinutes = parseInt(maxTimeStr);
        } else if (maxTimeStr && maxTimeStr.toLowerCase() === "unlimited") {
          maxMinutes = 240; // Default max for "unlimited" ticket scenario (e.g., 4 hours) - adjust as needed
        } else {
          maxMinutes = 120; // Default if parsing fails (e.g., 2 hours) - adjust as needed
        }

        if (maxMinutes <= 0) {
          showStatus(
            `Ticket required, but time limit is zero or invalid (${maxTimeStr}). Cannot park.`,
            5000
          );
          currentParkingSession.rule = `Ticket Error (${maxTimeStr})`;
          saveParkingSession(currentParkingSession);
          return;
        }

        // Generate time options (e.g., 30 min increments up to max)
        for (let minutes = 30; minutes <= maxMinutes; minutes += 30) {
          const hours = Math.floor(minutes / 60);
          const mins = minutes % 60;
          let timeLabel = "";
          if (hours > 0) timeLabel += `${hours}hr `;
          if (mins > 0) timeLabel += `${mins}min`;

          const btn = document.createElement("button");
          btn.classList.add("time-option-btn");
          btn.textContent = timeLabel.trim();
          btn.dataset.minutes = minutes;
          btn.onclick = () => {
            ticketTimeModal.classList.remove("visible");
            // Use the selected minutes as the time string for handleTimeSelection
            handleTimeSelection(minutes.toString(), side, true); // Pass true for isTicketed
          };
          ticketTimeOptionsContainer.appendChild(btn);
        }

        ticketTimeModal.classList.add("visible"); // Show the modal
      }

      // --- handleTimeSelection Function --- (Unchanged)
      function handleTimeSelection(timeStr, side, isTicketed = false) {
        let ruleDescription = "";
        if (timeStr === null || timeStr === undefined) {
          showStatus("Error: No time information available.", 4000);
          ruleDescription = "Error - Unknown Time";
          saveParkingSession({ ...currentParkingSession, rule: ruleDescription });
          return;
        }

        const timeLower = timeStr.toString().toLowerCase();

        if (timeLower === "no parking") {
          showStatus(`No parking allowed on the ${side} side.`, 4000);
          ruleDescription = "No Parking";
          timerCardContainer.style.display = "none"; // Hide timer card
        } else if (timeLower === "unlimited") {
          showStatus(
            `Unlimited parking on ${side} side.${
              isTicketed ? " (Ticket purchased)" : ""
            }${
              currentParkingSession.isDisabilityParking
                ? " (Disability Permit)"
                : ""
            }`,
            4000
          );
          ruleDescription = `Unlimited Parking${isTicketed ? " (Ticket)" : ""}${
            currentParkingSession.isDisabilityParking
              ? " (Disability Permit)"
              : ""
          }`;
          timerCardContainer.style.display = "none"; // Hide timer card for unlimited
        } else {
          const minutes = parseInt(timeLower);
          if (!isNaN(minutes) && minutes > 0) {
            startTimers(minutes); // Start the timer
            ruleDescription = `${minutes} min Parking${
              isTicketed ? " (Ticket)" : ""
            }${
              currentParkingSession.isDisabilityParking
                ? " (Disability Permit)"
                : ""
            }`;
            showStatus(
              `Timer set for ${minutes} min on ${side} side.${
                isTicketed ? " (Ticket purchased)" : ""
              }${
                currentParkingSession.isDisabilityParking
                  ? " (Disability Permit)"
                  : ""
              }`,
              4000
            );
            // Timer card display is handled by startTimers()
          } else {
            // Handle cases where timeStr is neither "no parking", "unlimited", nor a valid number
            showStatus(
              `Could not determine parking time from "${timeStr}" on ${side} side. Assuming unlimited.`,
              5000
            );
            ruleDescription = `Unlimited Parking (Unknown Time: ${timeStr})${isTicketed ? " (Ticket)" : ""}${
              currentParkingSession.isDisabilityParking
                ? " (Disability Permit)"
                : ""
            }`;
            timerCardContainer.style.display = "none"; // Hide timer card
          }
        }
        currentParkingSession.rule = ruleDescription; // Set the final rule description
        saveParkingSession(currentParkingSession); // Save the session details
      }


      // --- Timers & Alarm --- (Unchanged)
      function startTimers(totalMinutes) {
        stopTimers(); // Ensure previous timers are cleared
        const warningMinutes = Math.max(0, totalMinutes - 15); // 15-minute warning or 0 if total < 15
        const now = Date.now();
        const warningEndTime = now + warningMinutes * 60 * 1000; // Time when warning should start
        const parkingEndTime = now + totalMinutes * 60 * 1000; // Time when parking expires
        const expiryDate = new Date(parkingEndTime);

        expiryTimeEl.textContent = `Expires: ${expiryDate.toLocaleTimeString(
          [],
          { hour: "numeric", minute: "2-digit" }
        )}`; // Display expiry time

        function updateTimerDisplay() {
          const currentTime = Date.now();
          let parkingTimeLeft = parkingEndTime - currentTime; // Total time left
          let warningTimeLeft = warningEndTime - currentTime; // Time until warning starts

          if (parkingTimeLeft <= 0) {
            // Timer expired
            warningTimeEl.textContent = "EXPIRED";
            expiryTimeEl.textContent = `Expired at: ${expiryDate.toLocaleTimeString(
              [],
              { hour: "numeric", minute: "2-digit" }
            )}`;
            if (!alarmHasTriggered) {
              triggerAlarm(); // Trigger alarm only once on expiry
              alarmHasTriggered = true;
            }
             warningTimeEl.classList.add("pulse"); // Keep pulsing when expired
          } else if (warningTimeLeft <= 0) {
            // Warning period (last 15 mins or less)
            warningTimeEl.textContent = formatTime(parkingTimeLeft); // Display remaining time
            if (!alarmHasTriggered) {
              triggerAlarm(); // Trigger alarm when warning period starts
              alarmHasTriggered = true;
            }
            warningTimeEl.classList.add("pulse"); // Start pulsing
          } else {
            // Before warning period
            warningTimeEl.textContent = formatTime(warningTimeLeft); // Display time until warning
            warningTimeEl.classList.remove("pulse"); // No pulsing yet
          }
        }

        alarmHasTriggered = false; // Reset alarm trigger flag
        timerIntervals.push(setInterval(updateTimerDisplay, 1000)); // Start interval timer
        updateTimerDisplay(); // Initial display update

        timersActive = true; // Set timer state
        timerCardContainer.style.display = "block"; // Show timer container
        timerCard.style.display = "block"; // Show timer card
        stopTimerBtn.style.display = "block"; // Show stop button
      }
      function handleStopTimer() {
        if (
          confirm("Are you sure you want to stop the current parking timer?")
        ) {
          stopTimersActions();
        }
      }
      function stopTimersActions() {
        timerIntervals.forEach((intervalId) => clearInterval(intervalId)); // Clear all intervals
        timerIntervals = []; // Reset intervals array
        timersActive = false; // Update state
        alarmHasTriggered = false; // Reset alarm flag
        silenceAlarm(); // Stop alarm sound if playing

        // Reset timer UI elements
        stopTimerBtn.style.display = "none";
        timerCard.style.display = "none";
        timerCardContainer.style.display = "none";
        warningTimeEl.classList.remove("pulse");
        warningTimeEl.textContent = "00:00:00";
        expiryTimeEl.textContent = "";

        showStatus("Timer stopped.", 2000);
      }
      function stopTimers() { // Public function to stop timers (used by retake etc.)
        stopTimersActions();
      }
      function formatTime(ms) {
        if (ms <= 0) return "00:00:00";
        const totalSeconds = Math.floor(ms / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        return `${hours.toString().padStart(2, "0")}:${minutes
          .toString()
          .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
      }
      function triggerAlarm() {
         // Check if the alarm sound is not already the intended alarm source
         // Use a more reliable check than just the filename if possible
         // For simplicity, we check if the src does NOT include 'silence'
         if (!alarmAudio.src || alarmAudio.src.includes("silence")) {
             console.log("Triggering alarm sound...");
             // --- IMPORTANT: Use a reliable, LOUD alarm sound URL ---
             // Example: Replace with a better alarm sound if needed
             alarmAudio.src = "https://cdn.glitch.global/cbdf53ed-1d1e-441b-8c47-ff223e3a04c8/emergency-alarm-with-reverb-29431.mp3?v=1741136155983"; // Replace with your actual alarm sound
             alarmAudio.load(); // Load the new source
             alarmAudio.play().catch((e) => console.error("Alarm play failed on trigger:", e));
         } else if (alarmAudio.paused) {
             // If the correct alarm sound is loaded but paused, just play it
             console.log("Restarting paused alarm sound...");
             alarmAudio.play().catch((e) => console.error("Alarm restart failed:", e));
         }
         // If it's already playing the correct sound, do nothing
      }

      function silenceAlarm() {
         // Check if the audio source is NOT the silence track
         if (alarmAudio.src && !alarmAudio.src.includes("silence")) {
             console.log("Silencing alarm sound...");
             alarmAudio.pause(); // Stop playback
             // --- Set back to the silent track ---
             alarmAudio.src =
                 "https://cdn.glitch.global/16c2e168-5f80-4256-858b-ebbfd77da240/5-seconds-of-silence.mp3?v=1739673346964";
             alarmAudio.load(); // Load the silence track
             // Attempt to play silence to keep audio channel potentially active for background playback
             alarmAudio.play().catch((e) => {
                 // Ignore errors playing silence, common in background/locked screen
                 // console.warn("Could not play silence audio:", e.message);
             });
         }
      }


      // --- UI Updates --- (Unchanged)
      function showStatus(message, duration = 3000) {
        console.log("Status:", message);
        if (statusTimeout) clearTimeout(statusTimeout); // Clear existing timeout
        status.textContent = message;
        status.classList.add("visible");
        statusTimeout = setTimeout(() => {
          status.classList.remove("visible");
        }, duration);
      }
      function updateSignGraph(
        side,
        timeValue,
        signUsed,
        ticketRequired,
        disabledOnly,
        isParkingAllowed, // Added parameter
        isDisabilityOverride = false // Added parameter
      ) {
        const header = side === "left" ? leftSignHeader : rightSignHeader;
        const timeEl = side === "left" ? leftTime : rightTime;
        const signEl = side === "left" ? leftSign : rightSign;
        const ticketEl = side === "left" ? leftTicket : rightTicket;
        const disabledEl = side === "left" ? leftDisabled : rightDisabled;

        timeEl.textContent = timeValue || "N/A";
        signEl.textContent = signUsed || "N/A";
        ticketEl.textContent = ticketRequired ? "Yes" : "No";
        disabledEl.textContent = disabledOnly ? "Yes" : "No";

        let headerClass = "sign-header"; // Base class
        let headerText = `${side.toUpperCase()} SIDE`;

        // Determine card styling and header text based on allowance and type
        if (isDisabilityOverride) {
          headerClass += " disabled-allowed"; // Blue style for disability override
          headerText += ` - DISABLED PERMIT OK`;
        } else if (!isParkingAllowed) {
          headerClass += " no-parking"; // Red style for not allowed
          headerText += ` - NO PARKING (${
            disabledOnly && !settings.disabilityPermit // If it's disabled only and user lacks permit
              ? "Permit Req."
              : timeValue // Otherwise show the time rule that prohibits
          })`;
        } else if (ticketRequired) {
          headerClass += " ticket"; // Yellow style for ticket required
          headerText += ` - TICKET REQ. (${timeValue})`;
        } else if (timeValue.toLowerCase() === "unlimited") {
          headerClass += " allowed"; // Green style for unlimited allowed
          headerText += " - UNLIMITED";
        } else if (!isNaN(parseInt(timeValue))) {
          headerClass += " allowed"; // Green style for timed allowed
          headerText += ` - ${timeValue} MIN`;
        } else {
          // Fallback for unexpected allowed states (should ideally not happen often)
          headerClass += " allowed"; // Default to allowed if isParkingAllowed is true but details unclear
          headerText += ` - Check Sign (${timeValue})`;
        }

        header.className = headerClass; // Apply the determined class
        header.textContent = headerText; // Set the header text
      }


      // --- Service Worker --- (Unchanged)
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("/service-worker.js")
            .then((reg) => console.log("SW registered.", reg))
            .catch((err) => console.log("SW registration failed:", err));
        });
      }

      // --- PWA Install Prompt Listener --- (Unchanged)
      window.addEventListener("beforeinstallprompt", (e) => {
        console.log("beforeinstallprompt event captured.");
        e.preventDefault();
        deferredPrompt = e;
        // Only enable button if gate is visible and showing Android section
        if (
          installGate.style.display !== "none" &&
          androidInstallPrompt.style.display !== "none"
        ) {
          console.log("Enabling Android install button.");
          installBtnAndroid.disabled = false;
          installBtnAndroid.textContent = "Install ParkEase";
        }
      });

      // --- Android Install Button Listener --- (Unchanged)
      installBtnAndroid.addEventListener("click", async () => {
        if (deferredPrompt) {
          deferredPrompt.prompt();
          const { outcome } = await deferredPrompt.userChoice;
          console.log(`User response to the install prompt: ${outcome}`);
          if (outcome === "accepted") {
            console.log("User accepted the install prompt");
            installBtnAndroid.textContent = "Installing...";
            installBtnAndroid.disabled = true;
            // Optionally hide the install gate after a short delay
            // setTimeout(() => { installGate.style.display = 'none'; initializeAppCore(); }, 2000);
          } else {
            console.log("User dismissed the install prompt");
            // Maybe show a message explaining they can still install later from browser menu
          }
          deferredPrompt = null; // Consume the prompt
        } else {
          console.log("Install prompt not available or already used.");
          installBtnAndroid.textContent = "Install Unavailable";
          installBtnAndroid.disabled = true;
        }
      });

      // --- Initial Check & Run --- (Unchanged)
      document.addEventListener(
        "DOMContentLoaded",
        checkInstallationAndInitialize
      );
    </script>
  </body>
</html>
